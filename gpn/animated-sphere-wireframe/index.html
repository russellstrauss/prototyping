<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - interactive particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="assets/js/three.min.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>
		
			var nodeBehindSphere = function(node, sphereMesh, edgeCaseMargin) {
				// edgeCaseMargin: If you want to change the value slightly so that nodes will show slightly before or after moving behind sphere rather than exactly when tangent lines are equal. Right now this value is based on three.js point distance
				edgeCaseMargin = edgeCaseMargin || 0;
				var radius = sphereMesh.geometry.parameters.radius;
				var D = camera.position.distanceTo(sphereMesh.position);
				var L = Math.sqrt(D*D - radius * radius);
				return (camera.position.distanceTo(node.position) > (L + edgeCaseMargin));
			};
			var interpolateNodeDistance = function(currentNode, closestNode, farthestNode) {
				// where Rn is the ratio calculated as a linear interpolation between R1 (max scale) and R2 (min scale) based on the distance. In other words, choose a scale, in this case between .25 and 1, and then figure out what the in-between value would be for that point that is closer than point 2, but farther than point 1. http://www.isda.org/c_and_a/pdf/Linear-interpolation-example.pdf
				
				var closestDistance = closestNode.position.distanceTo(camera.position);
				var farthestDistance = farthestNode.position.distanceTo(camera.position);
				var currentDistance = currentNode.position.distanceTo(camera.position);
				
				var R1 = 1; // Ratio of scale for closest node, aka original size
				var R2 = backgroundNodeScale; // Ratio of scale for farthest node
				var t1 = closestDistance;
				var t2 = farthestDistance;
				var tn = currentDistance;
				
				var Rn = R1 + ((R2 - R1)/(t2 - t1))*(tn - t1);
				
				return Rn;
			};
			
			var tempVector = new THREE.Vector3();
			var setUpNodes = function(i) {
				
				if (i == 0) { // initialize closest and farthest node variables
					isoMesh.userData.closestNode = nodes[0];
					isoMesh.userData.farthestNode = nodes[0];
				}
				// set closest node
				if (isoMesh.userData.closestNode.position.distanceTo(camera.position) > nodes[i].position.distanceTo(camera.position)) {
					isoMesh.userData.closestNode = nodes[i];
				}
				if (isoMesh.userData.farthestNode.position.distanceTo(camera.position) < nodes[i].position.distanceTo(camera.position)) {
					isoMesh.userData.farthestNode = nodes[i];
				}
				var distanceScale = interpolateNodeDistance(nodes[i], isoMesh.userData.closestNode, isoMesh.userData.farthestNode);
				nodes[i].scale.set(distanceScale, distanceScale, distanceScale);
				
				// Set inital positions of nodes
				tempVector.copy(isoMesh.geometry.vertices[i]);
				nodes[i].position.copy(isoMesh.localToWorld(tempVector));
				scene.add(nodes[nodes.length - 1]);
				
				// BUG: this not running correctly because of spehere position, opacity for backside nodes not set on initialize
				if (nodeBehindSphere(nodes[i], isoMesh, nodeVisibilityMargin)) { // hide initially if positioned on backside of sphere
					nodes[i].material.opacity = opacityFloor;
					//nodes[i].material.color.setHex(0xffff00);
				}
				
				// Initialize fade flag variables
				nodes[i].userData.fadeInComplete = false;
				nodes[i].userData.fadeOutComplete = false;
			};
			
			var fadeBackgroundNodes = function(i) {
				// Fade out when triggering visibilty
				if (!nodeBehindSphere(nodes[i], isoMesh, nodeVisibilityMargin)) { // In front of the sphere
					if (!nodes[i].userData.fadeInComplete) { // if fade in not complete, decrease opacity
						nodes[i].material.opacity += fadeSpeed;
						if (nodes[i].material.opacity >= 1) { // once finished, reset values
							nodes[i].material.opacity = 1;
							nodes[i].userData.fadeInComplete = true;
							nodes[i].userData.fadeOutComplete = false;
						}
					}
				}
				else { // Now behind the sphere, begin fade;
												
					if (!nodes[i].userData.fadeOutComplete) {
						nodes[i].material.opacity -= fadeSpeed;
						if (nodes[i].material.opacity <= opacityFloor) {
							nodes[i].material.opacity = opacityFloor;
							nodes[i].userData.fadeOutComplete = true;
							nodes[i].userData.fadeInComplete = false;
						}
					}
				}
			};
			
			var interpolateScaleNodes = function(i) { 
				// Scale nodes based on distance from camera, but normalized so that moving camera won't affect scale
				
				// set closest and farthest node
				if (isoMesh.userData.closestNode.position.distanceTo(camera.position) > nodes[i].position.distanceTo(camera.position)) {
					isoMesh.userData.closestNode = nodes[i];
				}
				if (isoMesh.userData.farthestNode.position.distanceTo(camera.position) < nodes[i].position.distanceTo(camera.position)) {
					isoMesh.userData.farthestNode = nodes[i];
				}
				
				var distanceScale = interpolateNodeDistance(nodes[i], isoMesh.userData.closestNode, isoMesh.userData.farthestNode);
				nodes[i].scale.set(distanceScale, distanceScale, distanceScale);
			};
		
			var requestAnimationFrameID;
			var container, stats;
			var camera, scene, renderer;
			var raycaster, mouse, intersects;
			var isoMesh;
			var nodes = [];
			var nodeRadius = 6;
			var isoRadius = 100;
			var opacityFloor = 0.3;
			var fadeSpeed = 0.04;
			var wireframeColor = 0xb8c0c8;
			var nodeVisibilityMargin = 50;
			var count = 0;
			var backgroundNodeScale = .6;
			
			init();
			animate();

			function init() {
				
				container = document.createElement('div');
				document.body.appendChild(container);
				
				var WIDTH = window.innerWidth,
				HEIGHT = window.innerHeight,
				FOV = 35,
				NEAR = 1,
				FAR = 1000;
				
				camera = new THREE.PerspectiveCamera(FOV, WIDTH / HEIGHT, NEAR, FAR);
				camera.position.set(400, 0, -300);

				scene = new THREE.Scene();

				isoGeometry = new THREE.IcosahedronGeometry(isoRadius, 1);
				var material = new THREE.MeshBasicMaterial({
					color: wireframeColor,
					wireframe: true
				});
				
				isoMesh = new THREE.Mesh(isoGeometry, material);
				// Interpolate method being messed up by position of isocahedron
				//isoMesh.position.set(-50, 25, 0);
				scene.add(isoMesh);
				
				var nodeGeometry = new THREE.CircleGeometry(nodeRadius, 32);
				
				for (var i = 0; i < isoGeometry.vertices.length; ++i) {
					var nodeMaterial = new THREE.MeshBasicMaterial({
						color: wireframeColor,
						transparent: true
					});
					var nodeMesh = new THREE.Mesh(nodeGeometry, nodeMaterial);
					nodes.push(nodeMesh);
					
					setUpNodes(i);
				}
				


				renderer = renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setClearColor(0xf0f0f0);
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);
				
				//raycaster = new THREE.Raycaster();
				//mouse = new THREE.Vector2(9999,9999);
				
				stats = new Stats();
				container.appendChild(stats.dom);
				
				//renderer.domElement.addEventListener('mousemove', onDocumentMouseMove);
				window.addEventListener('resize', onWindowResize, false);

			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}
			
			function onDocumentMouseMove(event) 
			{
				event.preventDefault();
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
			}
			
			
			function updateVertices(){
				if (typeof isoMesh !== "undefined" && typeof nodes !== "undefined" && nodes.length === isoMesh.geometry.vertices.length) {
					
					isoMesh.rotation.x += 0.005;
					isoMesh.rotation.y += 0.002;
					if (isoMesh.rotation.x > 360) isoMesh.rotation.x = 0;
					if (isoMesh.rotation.y > 360) isoMesh.rotation.y = 0;
					
					for (var i = 0; i < nodes.length; ++i) {
						tempVector.copy(isoMesh.geometry.vertices[i]);
						nodes[i].position.copy(isoMesh.localToWorld(tempVector));
						nodes[i].lookAt(camera.position);
						
						fadeBackgroundNodes(i);
						interpolateScaleNodes(i);
					}
				}
			}

			function animate() {
				
				try {								
					requestAnimationFrameID = requestAnimationFrame(animate);
					render();
					stats.update();
					count++;
				}
				catch(error) {  
					console.log(error);
					cancelAnimationFrame(requestAnimationFrameID);
				}
			}

			function render() {
				
				// mouse detection using raycasting
				// raycaster.setFromCamera(mouse, camera);				
				// intersects = raycaster.intersectObjects(scene.children);
				// if (intersects.length > 0) intersects[0].object.material.color.setHex(0xff0000);
				
				if (typeof updateVertices !== "undefined") {
					updateVertices();
				}
				
				camera.lookAt(scene.position);
				camera.updateMatrixWorld();
				renderer.render(scene, camera);
			}

		</script>

	</body>
</html>
