<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - interactive particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="build/three.js"></script>

		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>

		<script src="js/libs/stats.min.js"></script>

		<script>
		
			var nodeBehindSphere = function(node, sphereMesh, edgeCaseMargin) {
				// edgeCaseMargin: If you want to change the value slightly so that nodes will show slightly before or after moving behind sphere rather than exactly when tangent lines are equal. Right now this value is based on three.js point distance
				edgeCaseMargin = edgeCaseMargin || 0;
				var radius = sphereMesh.geometry.parameters.radius;
				var D = camera.position.distanceTo(sphereMesh.position);
				var L = Math.sqrt(D*D - radius * radius);
				return (camera.position.distanceTo(node.position) > (L + edgeCaseMargin));
			};
			var interpolateNodeDistance = function(currentNode, closestNode, farthestNode) {
				// where Rn is the ratio calculated as a linear interpolation between R1 (max scale) and R2 (min scale) based on the distance. In other words, choose a scale, in this case between .25 and 1, and then figure out what the in-between value would be for that point that is closer than point 2, but farther than point 1. http://www.isda.org/c_and_a/pdf/Linear-interpolation-example.pdf
				
				var closestDistance = closestNode.position.distanceTo(camera.position);
				var farthestDistance = farthestNode.position.distanceTo(camera.position);
				var currentDistance = currentNode.position.distanceTo(camera.position);
				
				var R1 = 1; // Ratio of scale for closest node, aka original size
				var R2 = backgroundNodeScale; // Ratio of scale for farthest node
				var t1 = closestDistance;
				var t2 = farthestDistance;
				var tn = currentDistance;
				
				var Rn = R1 + ((R2 - R1)/(t2 - t1))*(tn - t1);
				
				return Rn;
			};
		
			// todo
			// 1. Interpolate size of nodes based on ratio of closest and farthest nodes
			var requestAnimationFrameID;
			var container, stats;
			var camera, scene, renderer;
			var raycaster, mouse, intersects;
			var geometry;
			var nodes = [];
			var circle;
			var sprite;
			var nodeRadius = 8;
			var isoRadius = 200;
			var isoMesh;
			var opacityFloor = 0.1;
			var fadeSpeed = 0.04;
			var wireframeColor = 0xb8c0c8;
			var closestNodeDistance;
			var farthestNodeDistance;
			var nodeVisibilityMargin = 50;
			
			var backgroundNodeScale = .75;
			
			

			init();
			animate();

			function init() {
				
				container = document.createElement('div');
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
				camera.position.set(-400, 0, -300);

				scene = new THREE.Scene();

				geometry = new THREE.IcosahedronGeometry(isoRadius, 1);
				var material = new THREE.MeshBasicMaterial({
					color: wireframeColor,
					wireframe: true
				});
				isoMesh = new THREE.Mesh(geometry, material);
				scene.add(isoMesh);

				// update geometry with new rotations
				isoMesh.updateMatrix(); 
				isoMesh.geometry.applyMatrix(isoMesh.matrix);
				isoMesh.matrix.identity();
				isoMesh.geometry.verticesNeedUpdate = true;
				
				// normalize
				isoMesh.position.set(0, 0, 0);
				isoMesh.rotation.set(0, 0, 0);
				isoMesh.scale.set(1, 1, 1);

				var segments = 30;
				var circleGeometry = new THREE.CircleGeometry(nodeRadius, segments);
				circleGeometry.vertices.shift();

				
				// Initialize all nodes
				for (var i = 0; i < geometry.vertices.length; i++) {

					var circleMaterial = new THREE.MeshBasicMaterial({ 
						color: wireframeColor, 
						transparent: true,
						overdraw: 0.75 
					});
					var circleMesh = new THREE.Mesh(circleGeometry, circleMaterial);

					nodes.push(circleMesh);
					nodes[i].userData.fadeInComplete = false;
					nodes[i].userData.fadeOutComplete = false;

					scene.add(circleMesh);
					
					// Set position of all nodes and face them to camera
					nodes[i].position.copy(geometry.vertices[i]);
					nodes[i].lookAt(camera.position);
										
					if (nodeBehindSphere(nodes[i], isoMesh, nodeVisibilityMargin)) { // hide initially if positioned behind sphere
						nodes[i].material.opacity = 0;
					}
					if (i == 0) { // initialize closest and farthest nodes
						isoMesh.userData.closestNode = nodes[0];
						isoMesh.userData.farthestNode = nodes[0];
					}
					// update closest node
					if (isoMesh.userData.closestNode.position.distanceTo(camera.position) > nodes[i].position.distanceTo(camera.position)) {
						isoMesh.userData.closestNode = nodes[i];
					}
					if (isoMesh.userData.farthestNode.position.distanceTo(camera.position) < nodes[i].position.distanceTo(camera.position)) {
						isoMesh.userData.farthestNode = nodes[i];
					}
					var distanceScale = interpolateNodeDistance(nodes[i], isoMesh.userData.closestNode, isoMesh.userData.farthestNode);
					nodes[i].scale.set(distanceScale, distanceScale, distanceScale);
				}

				



				


				renderer = new THREE.CanvasRenderer();
				renderer.setClearColor(0xf0f0f0);
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);
				
				//raycaster = new THREE.Raycaster();
				//mouse = new THREE.Vector2(9999,9999);
				
				stats = new Stats();
				container.appendChild(stats.dom);
				
				//renderer.domElement.addEventListener('mousemove', onDocumentMouseMove);
				window.addEventListener('resize', onWindowResize, false);

			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}
			
			function onDocumentMouseMove(event) 
			{
				event.preventDefault();
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
			}

			function animate() {
				
				try {
					isoMesh.rotation.x += 0.005;
					isoMesh.rotation.y += 0.002;

					// update vertices
					isoMesh.updateMatrix(); 
					isoMesh.geometry.applyMatrix(isoMesh.matrix);
					isoMesh.rotation.set(0, 0, 0);
					
					for (var i = 0; i < geometry.vertices.length; i++) {
						
						nodes[i].position.copy(geometry.vertices[i]);
						nodes[i].lookAt(camera.position);
						
						// update closest and farthest nodes
						if (isoMesh.userData.closestNode.position.distanceTo(camera.position) > nodes[i].position.distanceTo(camera.position)) {
							isoMesh.userData.closestNode = nodes[i];
							closestNodeDistance = isoMesh.userData.closestNode.position.distanceTo(camera.position);
						}
						if (isoMesh.userData.farthestNode.position.distanceTo(camera.position) < nodes[i].position.distanceTo(camera.position)) {
							isoMesh.userData.farthestNode = nodes[i];
							farthestNodeDistance = isoMesh.userData.farthestNode.position.distanceTo(camera.position);
						}
						
						// Scale nodes based on distance from camera, but normalized so that moving camera won't affect scale
						var distanceScale = interpolateNodeDistance(nodes[i], isoMesh.userData.closestNode, isoMesh.userData.farthestNode);
						nodes[i].scale.set(distanceScale, distanceScale, distanceScale);
						
						// Fade out when triggering visibilty
						if (!nodeBehindSphere(nodes[i], isoMesh, nodeVisibilityMargin)) { // In front of the sphere
							if (!nodes[i].userData.fadeInComplete) { // if fade in not complete, decrease opacity
								nodes[i].material.opacity += fadeSpeed;
								if (nodes[i].material.opacity >= 1) { // once finished, reset values
									nodes[i].material.opacity = 1;
									nodes[i].userData.fadeInComplete = true;
									nodes[i].userData.fadeOutComplete = false;
								}
							}
						}
						else { // Now behind the sphere, begin fade;
							if (!nodes[i].userData.fadeOutComplete) {
								nodes[i].material.opacity -= fadeSpeed;
								if (nodes[i].material.opacity <= opacityFloor) {
									nodes[i].material.opacity = opacityFloor;
									nodes[i].userData.fadeOutComplete = true;
									nodes[i].userData.fadeInComplete = false;
								}
							}
						}
					}
										
					requestAnimationFrameID = requestAnimationFrame(animate);
					render();
					stats.update();
				}
				catch(error) {
					console.log(error);
					cancelAnimationFrame(requestAnimationFrameID);
				}
			}

			function render() {
				
				// mouse detection using raycasting
				// raycaster.setFromCamera(mouse, camera);				
				// intersects = raycaster.intersectObjects(scene.children);
				// if (intersects.length > 0) intersects[0].object.material.color.setHex(0xff0000);
				
				camera.lookAt(scene.position);
				camera.updateMatrixWorld();
				renderer.render(scene, camera);
			}

		</script>

	</body>
</html>
